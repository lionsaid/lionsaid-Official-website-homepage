# 如何在 Flutter 中实现丝滑的 120Hz 动画

> 120Hz 不只是“更快”，而是更稳定。我们把“稳定”拆成可被度量的指标，再逐一优化。

## 背景

当设备具备高刷新率时，用户的敏感度也会被放大。轻微的抖动或间歇性卡顿都会被放大感知。

我们把整条渲染链路拆成三段：

- 输入与事件调度
- 布局与重绘
- 栅格化与合成

## 关键瓶颈

1. **调度抖动**：UI 线程上有不可控的高耗时任务。
2. **过度绘制**：同一帧内重复绘制导致 GPU 压力上升。
3. **合成层复杂**：透明与阴影叠加造成频繁的合成回退。

## 优化策略

我们采用“先减法，再重构”的顺序：

- 识别 `build` 中的热点，拆出可缓存的子树
- 合并大面积透明图层，减少 overdraw
- 将重计算移至 `Isolate` 或后台队列
- 为动画设置明确的节奏与节拍（避免微小不一致）

示例（简化）：

```
// 关键组件拆分成可复用子树
Widget build(BuildContext context) {
  return RepaintBoundary(
    child: AnimatedBuilder(
      animation: controller,
      builder: (_, __) => _CardShell(progress: controller.value),
    ),
  );
}
```

## 结果

- ProMotion 设备上可稳定保持 120Hz
- 峰值掉帧显著降低
- 设备温度与功耗在可控范围

## 结语

高刷新体验是对细节的考验。它要求工程与设计协同，要求每一帧都“有理由”。这也是我们坚持工匠化打磨的原因。
